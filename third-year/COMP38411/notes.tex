% ================================ Lecture 1 ===================================

\card{ \normalfont
  What does \textbf{network security} consist of?
}{ \normalfont
 \begin{flushleft}
   - Security problems and countermeasures in the transmission of information. \\
   - Security problems and countermeasures in networked computer systems.
 \end{flushleft}
 Network Security
}

\card{ \normalfont
  What are some examples of \textbf{security threats}?
}{ \normalfont
  \begin{flushleft}
    - Disclosure \\
    - Deception \\
    - Disruption \\
    - Attacks via Malware \\
    - Hacking as a Service \\
  \end{flushleft}
  Security Threats
}

\flashcard{ \normalfont
  \blank{\textbf{Disclosure}} is the release of message contents to any person or process not possessing the appropriate cryptographic key (e.g. \blank{snooping}, \blank{sniffing}).
}

\flashcard{ \normalfont
  \blank{\textbf{Deception}} examples include:
  \begin{flushleft}
    - Interception \\
    - Modification \\
    - Spoofing \\
    - Repudiation of origin \\
    - Denial of receipt \\
  \end{flushleft}
  Security Threats
}

\flashcard{ \normalfont
  \blank{\textbf{Disruption}} examples include:
  \begin{flushleft}
    - Modification \\
    - Delay \\
    - Denial of Service (DoS) \\
  \end{flushleft}
  Security Threats
}

\card{ \normalfont
  What are some examples of \textbf{malware types} from Attacks Via Malware?
}{ \normalfont
  \begin{flushleft}
    - Worms
    - Viruses
    - Trojan
  \end{flushleft}
  Malware Types
}

\card{ \normalfont
  What are some \textbf{security problems and challenges}?
}{\normalfont \small
  \begin{flushleft}
    - Naive users: lack of security awareness \\
    - Inadequate management procedures \\
        - Insecure system set-up and configuration \\
        - Lack of proper policy making, implementation and enforcement procedures \\
    - Global networks without national boundaries \\
    - Heterogeneous devices, e.g. laptops, iPhones and PDAs, with universal connections \\
    - Wireless and open channels \\
    - Anonymous nature of many internet based services \\
  \end{flushleft}
  Security Problems and Challenges
}

\flashcard{ \normalfont
  Securing information through CIA: \\
  \begin{flushleft}
    - \blank{\textbf{Confidentiality}}: keeping data and resources hidden \\
    - \blank{\textbf{Integrity}}: data \blank{integrity} (making sure data is authentic) and origin \blank{integrity} (authentication) \\
    - \blank{\textbf{Availability}}: ensuring data/service is available to authorised users.
  \end{flushleft}
  CIA
}

\card{ \normalfont
  What is the \textbf{life cycle} of \textbf{achieving security}?
}{ \normalfont \small
  \begin{flushleft}
    - Threats analysis and identification: decide \textbf{what to protect} \\
    - Policy specification (defining security goals): define \textbf{what is, and is not, allowed} \\
    - Design and implementation (enforcing policies to achieve security goal): decide \textbf{how to protect} in order to \textbf{satisfy the specification} with technical and procedural measures \\
    - Operation and maintenance (security assurance): assess \textbf{how well} the implementation has \textbf{achieved} its security \textbf{goal}
  \end{flushleft}
  Life Cycle of Achieving Security
}

\flashcard{ \normalfont
  An \blank{\textbf{Attack Tree (Threat Tree)}} is a conceptual diagram showing how an asset, or target, might be attacked.
}

\card{ \normalfont
  What does an \textbf{Attack Tree} consists of?
}{ \normalfont
  \begin{flushleft}
    - root node: the attack goal \\
    - children nodes: conditions which must be satisfied to make the direct parent node true \\
    - leaf nodes
  \end{flushleft}
  Attack Tree
}

\card{ \normalfont
  What are the two conditions in an Attack Tree?
}{\normalfont
  \begin{flushleft}
    - OR: represents alternative attack methods or avenues in the attack \\
    - AND: represents multiple steps in launching an attack
  \end{flushleft}
  Attack Tree Conditions
}

\flashcard{ \normalfont
  Each node may be given a value to indicate, e.g: \\
  \begin{flushleft}
    - \blank{Likelihood} that an attacker will mount the attack, or \blank{probability} of succeeding the attack \\
    - \blank{Cost} in succeeding the attack, in terms of monetary cost, or time taken to accomplish the attack, etc. \\
  \end{flushleft}
  Like this you could identify and make a decision as what, where and how to protect your asset.
}

\flashcard{ \normalfont
  \blank{\textbf{Security measures}} are a method, protocol, tool or procedure used to address the risks identified (or to enforce a security policy).
}

\flashcard{ \normalfont
  \blank{Prevention} is a security measure which:
  \begin{flushleft}
    - Block attacks by closing vulnerabilities \\
    - Reduce the level of risks by making attacks harder \\
    - Make another target more attractive than this one \\
    - E.g. access control (firewalls), encryption, digital signatures
  \end{flushleft}
  Security Measures
}

\flashcard{ \normalfont
  \blank{Detection} is a security measure which measures taken during or after the attacks, e.g. auditing and intrusion \blank{\textbf{detection}}.
}

\flashcard{\normalfont
  \blank{\textbf{Recovery}} is a security measure which stops attacks, asses and repairs damage. It continues t function correctly even if the attacks succeed.
}

\flashcard{\normalfont
  A security measure consists of \blank{\textbf{accepting}} the attack and doing \blank{\textbf{nothing}}.
}

\flashcard{ \normalfont
  A \blank{\textbf{communication}} security model: emphasis is on protecting data while in transit.
}

\flashcard{\normalfont
  A \blank{\textbf{network}} security model: focus is on protecting data and services on a \blank{\textbf{network}} against external attacks or unauthorised usage. It has multi-level security measures, however, the use of mobile devices will make the boundary hard to define.
}

\flashcard{\normalfont
  An \blank{\textbf{e-commerce}} security model: the opponent is a misbehaving insider. The third party is now a trusted third party TTP, e.g an arbitrator, that offers some services. Non-repudiation services generate the evidence the arbitrator will consider when resolving a dispute.
}


% ================================ Lecture 2 ===================================
\flashcard{ \normalfont
  \blank{\textbf{Cryptography}} is \textit{the art of keeping messages secure}. (Schneier)
}

\card{ \normalfont
  What are some of the uses of \textbf{cryptography}?
}{ \normalfont \footnotesize
  \begin{flushleft}
    - Confidentiality (secrecy, privacy) of data in transmission and in storage \\
    - Integrity of data in transmission and in storage \\
    - Origin authentication of data \\
    - Authentication of identity \\
    - Credentialing systems (a proof of qualifications or competence of a person) \\
    - Digital signatures \\
    - Electronic money \\
    - Threshold cryptosystems \\
    - Secure multi-party communications \\
    - Digital right management \\
    - Electronic voting, etc.\\
  \end{flushleft}
  Cryptography Uses
}

\flashcard{ \normalfont
  \blank{\textbf{Encryption}} can be used to achieve secure communications over an insecure channel.
}

\flashcard{ \normalfont
  \blank{\textbf{Symmetric}} key based encryption uses conventional ciphers. The same key is used for encryption and decryption (e.g. historical ciphers, modern ciphers).
}

\flashcard{\normalfont
  \blank{\textbf{Asymmetric}} key based encryption uses public key ciphers. Different keys are used for encryption and decryption (e.g. modern ciphers).
}

\flashcard{\normalfont
  \blank{\textbf{Plaintext}} or \blank{\textbf{cleartext}} is a message in its original form.
}

\flashcard{\normalfont
  \blank{\textbf{Ciphertext}} is a message in an encrypted form.
}

\flashcard{\normalfont
  \blank{\textbf{Encryption}} is coding a message to hide its meaning, while \blank{\textbf{decryption}} is converting an \blank{\textbf{encrypted}} message back to its original form.
}

\flashcard{\normalfont
  \blank{\textbf{Cipher}} or \blank{\textbf{Cryptosystem}} is the system that performs encryption and decryption.
}

\flashcard{\normalfont
  An \blank{\textbf{unconditional security}} is the system that cannot be defeated, no matter how much power is available by the adversary.
}

\flashcard{\normalfont
  \blank{\textbf{Computational security}} is the perceived level of computation required to defeat the system using th best known attack exceeds, by a comfortable margin, the computational resources of the hypothesized adversary (e.g. given limited computing resources, it takes very long time to break a cipher).
}

\flashcard{\normalfont
  A \blank{\textbf{provable}} security means that the difficulty of defeating the system can be shown to be essentially as difficult as solving a well-known and supposedly difficult problem (e.g. integer factorisation).
}

\flashcard{\normalfont
  \blank{\textbf{Ad hoc}} security are claims of security which generally remain questionable, where unforseen attacks remain a threat.
}

\card{\normalfont
  What are the two classical ciphers?
}{\normalfont
  \begin{flushleft}
    1. Substitution ciphers: monoalphabetic and polyalphabetic. \\
    2. Transportation ciphers.
  \end{flushleft}
  Classical Ciphers
}

\card{\normalfont
  What are the encryption techniques?
}{\normalfont
  \begin{flushleft}
    - Classical (historical) algorithms are based on substitution (based on confusion, e.g. a becomes b) and permutation/transposition (based on diffusion, e.g. abcd becomes dacb) \\
    - XOR operator \\
    - Simple non-secure ciphers: Shift cipher - caesar cipher; Vigenere Cipher, etc. \\
    - Secure cipher: One-time pad
  \end{flushleft}
  Encryption Techniques
}

\flashcard{\normalfont \small
  \blank{\textbf{Ceaser Cipher}} or shift cipher uses simple substitution: each letter is translated to the letter a fixed number of letters after it in the alphabet. The operation could be expressed using addition modulo 26:
  \begin{flushleft}
    - The message must be a sequence of letters, each letter is identified with a number \\
    - The key k is a number in the range 1 to 25 \\
    - Encryption/decryption involves +- k to each letter (mod 26) \\
  \end{flushleft}
  Shift Cipher
}

\flashcard{\normalfont
  \blank{\textbf{Brute force attack}} or exhaustive key search tries all possible keys.
 }
 \card{\normalfont
   What are the three characteristics that make the Brute force attack practical?
 }{\normalfont
  \begin{flushleft}
    - The encryption and decryption algorithms are in public domain \\
    - There are only 25 keys to try out \\
    - The language of the plaintext is easily recognisable (e.g. compressed text not) \\
  \end{flushleft}
  Brute force attack practical reasons
}

\flashcard{\normalfont
  The \blank{\textbf{one-time pad}} is a special variant of the stream cipher and it is truly a perfect cipher: it uses a one-time random key that is as long as the plaintext with no repetitions (only used once). If used properly, it is provably unbreakable.
}

\card{\normalfont
  What are some of the \textbf{problems} of the \textbf{one-time pad}?
}{\normalfont
  \begin{flushleft}
    - No way to remember the entirety of the random key string. \\
    - It’s too expensive for most applications as it consumes as much key material as there is traffic. \\
    - Key management is hard as the need for non-repeating keys has a problem with storing and distributing them. \\
    - Absolute synchronisation between sender and receiver is really hard to achieve.\\
  \end{flushleft}
  Problems with the one-time pad
}

\card{\normalfont
  What is the main idea of a \textbf{stream cipher}?
}{\normalfont
  To replace the random key in one-time pad by a pseudo-random sequence, generated by a cryptographic pseudo-random generator that is seeded with the key. \\
  \textit{Ciphertext = plaintext XOR keystream} \\
  This is a dangerous security property and we must never reuse the same keystream to encrypt two different messages.
}

\flashcard{\normalfont
  The \blank{\textbf{transportation (permutation)}} texhnique performs a permutation on the plaintext.
}

\card{\normalfont
  What are some common types of \textbf{attacks}?
}{\normalfont
  \begin{flushleft}
    - Try to break or crack the algorithm by exploring any flaws in it e.g. frequency analysis. \\
    - Assume attacker recognises plaintext, try to decrypt ciphertext with every possible key until…, e.g. brute force attack (Also exhaustive key search attack) \\
    - Run the algorithm on massive amounts of plaintext and find the one plaintext that encrypts to the ciphertext that it’s being analysed, e.g. dictionary attack.\\
  \end{flushleft}
  Common types of attacks
}

\card{\normalfont
  Ciphertest-only attacks? (e.g. frequency attcks)
}{\normalfont
  \begin{flushleft}
    - Attacker knows ciphertexts of several messages encrypted with the same key, plaintext is recognisable. \\
    - The goal is to find the plaintext, possibly the key \\
  \end{flushleft}
  Ciphertext-only attacks
}

\card{\normalfont
  Known-plaintext attack? (e.g. dictionary attack)
}{\normalfont
  \begin{flushleft}
    - Attacker observes <plaintext, ciphertext> pairs encrypted with the same key. \\
    - The goal is to find the key. \\
  \end{flushleft}
  Known-plaintext attack
}

\card{\normalfont
  Chosen-plaintext attack?
}{\normalfont
  \begin{flushleft}
    - Attacker can choose the plaintext and look at the paired ciphertext. \\
    - The goal is to find the key. \\
  \end{flushleft}
  Chosen-plaintext attack
}

\flashcard{\normalfont
  \blank{\textbf{Cryptanalysis attacks}} often exploit the redundancy of natural language: lossless compression before encryption removes redundancy.
}


% ================================ Lecture 3 ===================================
\flashcard{\normalfont
  In a \blank{\textbf{block}} cipher, the plaintext is divided into \blank{blocks} of fixed length which are encrypted one at a time.
}


\card{\normalfont
  What is the \textbf{design criteria} of \textbf{block ciphers}?
}{\normalfont \small
  \begin{flushleft}
    - \textbf{Completeness}: each bit of the output should depend on every bit of the input and every bit of the key. \\
    - \textbf{Avalanche effect (Diffusion)}: changing one bit in the input should change many bits in the output. Also, changing one key bit should result in the change of many bits in the output.\\
    - \textbf{Statistical independence (Confusion)}: input and output should appear to be statistically independent.
    A complex encryption function can be built out of some simple operations (round function) by repeatedly using them.
  \end{flushleft}
  Design Criteria of Block Ciphers
}

\flashcard{\normalfont
  \blank{\textbf{Feistel block cipher}} is an example implementation of a block cipher. There is an initial permutation of bits which is then split in left and right halves. 16 rounds of identical operations, but each round uses a different subkey. Inverse initial permutation.
}

\flashcard{\normalfont
  Ciphers that use substitution and permutation are called \blank{\textbf{substitution-permutation (S-P) networks}}. They can be efficiently implemented on both hardware and software platforms.
}

\flashcard{\normalfont
  The \blank{\textbf{Data encryption Standard (DES)}} was first published in 1977 as a US Federal standard. IT is a de facto international standard for banking security. It’s a Feistel block cipher - block length is 64 bits, key K is 56 bits. The subkeys k1, k2… k16 are each 48 bits, generated from key K. \\
  The DES decryption algorithm is the same as the encryption one; the only difference is that the keys for each round must be used in reverse order, i.e k16 first and k1 last.
}

\card{\normalfont
  What is the architecture of \textbf{each round} of a \textbf{DES}?
}{\normalfont
  Li = Ri+1 and Ri - Li-1 xor f(Ri-1, Ki)
}

\card{\normalfont
  What are the steps of a \textbf{round function} of a \textbf{DES}?
}{\normalfont \small
  \begin{flushleft}
    1. \textbf{Expansion permutation}: Right half (32 bits) is expanded (and permuted) to 48 bits. Diffuses relationship of input bits to output bits. \\
    2. \textbf{Use of Round Key}: 48 bits are XOR-ed with the round key (48 bits). \\
    3. \textbf{Splitting}: result is split into eight lots of six bits each.\\
    4. \textbf{S-Box} (S = Substitution): each six bit lot is used as an index to an S-box to produce a four bit result.
    5. \textbf{P-Box} (P = Permutation): 32 bits output from 8 S-Boxes are permuted = the output of f.
  \end{flushleft}
  DES round function steps
}

\card{\normalfont
  What is the operation of an \textbf{S-Box}?
}{\normalfont
  \begin{flushleft}
    - Each of the 8 different S-boxes is a table of 4 rows and 16 columns \\
    - The 6 input bits specify which row and column, i.e. cell, to use. Bits 1 and 6 select the row, while bits 2-5 select the column.
    - The decimal value in the cell is then converted into a 4-bit result, which is the output from the S-box
  \end{flushleft}
  S-Box Operation
}

\card{\normalfont
  What is the \textbf{weakness} of an \textbf{S-Box}?
}{\normalfont
  \begin{flushleft}
    The 56-bit key which is good enough to deter casual DES key browsing, but not for a dedicated adversary. \\
    Use of a 56-bit key can be broken on average in 255 (i.e. 3.6 * 1016) trials. \\
    - A DES chip does 1 million encryptions per second.\\
    - A million chips in parallel do 1012 trials per second. \\
    For today’s computing power, the key size should be at least 128 bits. Improvements: Triple DES (3DES), AES (Rijndael).
  \end{flushleft}
  S-Box weakness
}

\flashcard{\normalfont
  \blank{\textbf{Triple DES}} involves use of \blank{two} or \blank{three} DES keys.
}

\card{\normalfont
  What are the \textbf{two types} of \textbf{Triple DES}?
}{\normalfont
  \begin{flushleft}
    1. EDE2 (triple DES using 2 keys): It uses 2 DES keys (K1, K2), encryption algorithm Em and decryption algorithm D, i.e. C = EK1(Dk2(EK1(M))). So the key length is 112 bits. The use of D here does not have any security implication; it just makes triple DEs backward competitive with single DES if K1 = K2.\\
    2. EDE3 (triple DES using three keys): It uses three keys, so C = EK3(Dk2(EK1(M))). The key length is 168 bits.
  \end{flushleft}
  Types of Triple DES
}

\card{\normalfont
  How does the \textbf{meet-in-the-middle attack} work?
}{\normalfont
  \begin{flushleft}
    A table of keys is built and f(k, M) computed for every possible key, where f is an encryption function, and M is a known message. Eavesdrop a value f(k’, M) and if it’s the same as f(k, M) then there is a good chance k’ = k.
  \end{flushleft}
  Meet-in-the-middle Attack
}

\card{\normalfont
  Why did NIST call for \textbf{algorithms} to \textbf{replace DES}?
}{\normalfont
  Because algorithm and implementation characteristics are fast and have low resource consumption. \\
  Cost: fast in both hardware and software.
}

\card{\normalfont
  What was the officially nominated \textbf{Advanced Encryption Standard (AES)} in 2001?
}{\normalfont
  Vincent Rijmen and Joan Daemen’s algorithm, Rijndael.
}

\flashcard{\normalfont
  \textbf{DES} and \textbf{AES} are both a \blank{\textbf{symmetric block}} cipher.
}

\card{\normalfont
  What does a \textbf{symmetric block cipher} entail?
}{\normalfont \footnotesize
  \begin{flushleft}
    - The same key is used to encrypt and decrypt the message. \\
    - The plaintext and the ciphertext have the same size. \\
    - Block size is 128 bits (others are allowed but not recognised by the standard). \\
    - The key lengths are 128 192, or 256 bits, i.e. the standard comprises three block ciphers: AES-128, AES-192 and AES-256. \\
    - It is a substitution-permutation cipher involving r rounds: For key length 128, r = 10; For key length 193, r = 12; For key length 256, r = 14.
  \end{flushleft}
  Symmetric block cipher properties
}

\card{\normalfont
  What does the \textbf{round transformation} consist of?
}{\normalfont
  \begin{flushleft}
    - Byte substitution. \\
    - Shift rows. \\
    - Mix columns. \\
    - Round key addition.
  \end{flushleft}
  Round Transformation Elements
}

\card{\normalfont
  What are some properties of the \textbf{AES}?
}{\normalfont
  AES has a sequential and light-weight key schedule. \\
  AES has a fixed block size of 128  bits (16 bytes) called a state.
}

\card{\normalfont
  How does the \textbf{substitute bytes} of an AES work?
}{\normalfont \small
  \begin{flushleft}
    - This SubBytes transformation is a simple table lookup. \\
    - Only one S-Box for the whole cipher, a 16 x 16 matrix of byte values, that contains a permutation of all possible 256 8-bit values. \\
    - Each individual byte of state is mapped into a new byte in this way: leftmost 4 bits of the byte are used as a row value; rightmost 4 bits used as a column value. \\
    - These row and column values serve as indexes into the S-box to select a unique 8-bit output value.
  \end{flushleft}
  AES Substitute Bytes
}

\card{\normalfont
  How does the \textbf{ShiftRows} transformation of an AES work?
}{\normalfont
  \begin{flushleft}
    - 1st row: not altered; \\
    - 2nd row: a 1-byte circular left shift; \\
    - 3rd row: a 2-byte circular left shift; \\
    - 4th row: a 3-byte circular left shift. \\
    Decryption uses shift to the right. \\
    This step permutes between the columns.
  \end{flushleft}
  AES ShiftRows
}

\card{\normalfont
  How does the \textbf{MixColumns} transformation of an AES work?
}{\normalfont
  The \textbf{MixColumns} transformation operates on each column individually. Each byte of a column is mapped into a new value hat is a function of all four bytes in the column; the transformation is performed in GF(28). \\
  This with \textbf{ShiftRows} transformation provides \textbf{diffusion}.
}

\card{\normalfont
  How does the \textbf{AddRoundKey} transformation of an AES work?
}{\normalfont
  In the \textbf{AddRoundKey} transformation, each byte of the state is combined with the round key using XOR, i.e. the 128 bits of state are bitwise XORed with the 128 bits of the round key (the round key is derived from the cipher key using a key schedule).
}

\card{\normalfont
  What is the pseudo-code for \textbf{AddRoundKey} for \textbf{AES-128 Encryption}?
}{\normalfont
  \begin{flushleft}
    \textbf{AddRoundKey(S, K[0]);} K[0] is the cipher key, K, and other round keys are expanded from K. \\
    for(i = 1; i<=9; i++)
    \begin{center}
      SubBytes(S); \\
      ShiftRows(S); \\
      MixColumns(S); \\
      AddROundKeys(S, K[i]);
    \end{center}
    SubBytes(S); \\
    ShiftRows(S); \\
    AddRoundKey(S, K[10]);
  \end{flushleft}
  AddRoundKey AES-128 Encryption Pseudo-code
}

\card{\normalfont
  What is the pseudo-code for \textbf{AddRoundKey} for \textbf{AES-128 Decryption}?
}{\normalfont
  \begin{flushleft}
    (first apply InvMixColumns to the round key) \\
    AddRoundKey(S, K[10]); \\
    for(i = 9; i>=1; i++) \\
    \begin{center}
      InvSubBytes(S); \\
      InvShiftRows(S); \\
      InvMixColumns(S); \\
      AddRoundKey(S, K[i]);
    \end{center}
    InvSubBytes(S); \\
    InvShiftRows(S); \\
    AddRoundKeys(S, K[0]);
  \end{flushleft}
  AddRoundKey AES-128 Decryption Pseudo-Code
}

\card{\normalfont
  What are the properties of a \textbf{DES}?
}{\normalfont
  \begin{flushleft}
    - Substitution-Permutation, iterated cipher, Feistel structure. \\
    - 64-bit block size, 56-bit key size. \\
    - 8 different S-boxes. \\
    - design optimised for hardware implementations. \\
    - closed (secret) design process.
  \end{flushleft}
  Data Encryption Standard (DES)
}

\card{\normalfont
  What are the properties of an \textbf{AES}?
}{\normalfont
  \begin{flushleft}
    - Substitution-Permutation, iterated cipher. \\
    - 128-bit block size, 128-bit (192 or 256) key size. \\
    - 1 S-Box. \\
    - Design optimised for byte-oriented implementations. \\
    - Open design and evaluation process.
  \end{flushleft}
  Advanced Encryption Standard (AES)
}

\card{\normalfont
  What are the three \textbf{modes of operation} when encrypting large messages?
}{\normalfont
  \begin{flushleft}
    - ECB - Electronic Code Book \\
    - CBC - Cipher Book Chaining \\
    - CTR - Counter mode \\
  \end{flushleft}
  These modes of operation have been standardised internationally and are applicable to any block ciphers.
}

\card{\normalfont
  What are the properties of an \textbf{ECB mode} encryption?
}{\normalfont \footnotesize
  \begin{flushleft}
    - Block are encrypted independently of other blocks. Reordering ciphertext blocks result in correspondingly reordered plaintext blocks. Ciphertext blocks can be cut from one message and pasted in another, so block replay or block insertion (or deletion) attacks may go undetected.\\
    - The same block of plaintext always produces the same ciphertext (with the same key): Patterns in plaintext show up in ciphertext. \\
    - Error propagation: one bit error in a ciphertext block affects only the corresponding plaintext block. \\
    - Not recommended for messages longer than one block, or if keys are reused for more than one block.
  \end{flushleft}
  ECB mode
}

\card{\normalfont
  What are the properties of a \textbf{CBC mode} encryption?
}{\normalfont \footnotesize
  \begin{flushleft}
    - Plaintext is divided into blocks and the last block is padded if necessary. \\
    - Cn = Ek(Mn xor Cn-1) where C0 = IV (initialisation vector)\\
    - In this example, the plaintext is M1M2, and the ciphertext is C0C1C2.\\
    - Ciphertext blocks Cj depends on Mj and all preceding plaintext blocks. Any repeated patterns in the plaintext are concealed by the feedback. \\
    - Using different IVs in different encryption operations will result in the same plaintext producing different ciphertexts.
  \end{flushleft}
  CBC mode
}

\card{\normalfont
  What are the properties of a \textbf{CTR mode} encryption?
}{\normalfont \footnotesize
  \begin{flushleft}
    - Uses a counter, equal to the plaintext block size. Its value must be different for each plaintext block. Typically the counter is initialised to some value, and then incremented by 1 for each subsequent block (modulo 2n, where n is the block length). \\
    - Each block can be decrypted independently of the others: Parallelizable, Support random access, The values to be XORed with the plaintext can be precomputed \\
    - The counter needs to be synchronised: If a block is inserted into or deleted from the ciphertext stream then synchronisation is lost and the plaintext cannot be recovered \\
    - No error propagation: A ciphertext block that is modified during transmission affects only the decryption of that block.
  \end{flushleft}
  CTR mode
}

\card{\normalfont
  What are the differences between a \textbf{block cipher} and a \textbf{stream cipher}?
}{\normalfont \footnotesize
  \begin{flushleft}
    While block ciphers encrypt block of characters, stream ciphers encrypt individual characters or bit streams. \\
    Stream ciphers:\\
    - Are usually faster than block ciphers in hardware; mostly used for continuous communications and/or real time applications. \\
    - Requires less memory space, so cheaper for resource restrained devices such as embedded sensors. \\
    - Have limited or no error propagation, so advantageous when transmission errors are probable. \\
    - Can be built out of block ciphers, e.g. by using CRT modes.
  \end{flushleft}
  Block Ciphers vs Stream Ciphers
}


% ================================ Lecture 4 ===================================
\flashcard{\normalfont
  \textbf{Conventional/ symmetric} cryptography is based on \blank{\textbf{shared secret keys}}.
}

\card{\normalfont
  What are the problems with \textbf{symmetric/ conventional cryptography}?
}{\normalfont
  \begin{flushleft}
    A separate key is needed for each pair of users (or even for each ciphertext encryption -> session key) \\
    - So an n-user system requires n*(n-1)/2 keys -> the n2 problem. \\
    - Generating and distributing these keys are a challenging problem. \\
    - Maintaining security for the keys already distributed is also challenging: can one remember so many keys? \\
    As two parties share the same key, non-repudiation can not be achieved.
  \end{flushleft}
  Problems with symmetric/ conventional cryptography
}

\flashcard{\normalfont
  \blank{\textbf{Public key}} cryptosystems are based on mathematically hard problems rather than substitution/ transportation (permutation) ciphers.
}

\card{\normalfont
  How does \textbf{public-key} cryptography work?
}{\normalfont
  \begin{flushleft}
    A pair of keys is used: One is private (secret), the other can be made public. The pair of private and public keys are related mathematically. It is infeasible to generate one from the other. \\
  Encryption generated with one key can only be decrypted with the other key in the pair.
  \end{flushleft}
  Public-key cryptography
}

\flashcard{\normalfont
  \blank{\textbf{Confidentiality}} protection is only applied to short messages, e.g. for secure transportation of symmetrical keys. \\
  It is achieved by encrypting the plaintext M using the recipient's public key. Only the recipient has the corresponding private key so M can only be read by the recipient.
}

\flashcard{\normalfont
  A \blank{\textbf{signature}} is put on the hash value of M, and a \blank{\textbf{timestamp}} should also be included. This is used for message authentication and integrity and non repudiation of message origin. \\
  It it achieved by \blank{signing} M (actually the hash of it) using the sender's \textbf{private key}. Only the seder has the private key, so the message must have been signed by the sender.
}

\flashcard{\normalfont
  \blank{\textbf{Public key cryptography}} is based on the idea of a \textit{trapdoor} function, or mathematically hard problems.
}

\card{\normalfont
  Why is PKC using mathematically hard problems?
}{\normalfont
  \begin{flushleft}
    - Easy to generate keys (public and private) \\
    - Easy to encrypt and decrypt if the right key is known. \\
    - Hard to compute private key from public key. \\
    - Hard to recover plaintext from ciphertext without the right key.
  \end{flushleft}
  Reasons for using mathematically hard problems for PKC
}

\card{\normalfont
  What is the mathematical definition of \textbf{modulo}?
}{\normalfont
  \textit{a = b mod n}, which means there exists an integer number k such that a can be represented as a = k *n + b with the condition that 0 <= b <= n-1. \\
  Given integers a, b, and n != 0, a is congruent to b modulo n, if and only if a - b = k * n for some integer k, i.e. n divided (a-b). The notation is a = b (mod n). We call n the \textbf{modulus}, and b is \textbf{remainder} or \textbf{residue} of a modulo n.
}

\card{\normalfont
  What does the \textbf{RSA algorithm} consist of?
}{\normalfont
  \begin{flushleft}
    The algorithm consists of two numbers, the modulus (represented by the letter n) and the public exponent (represented by the letter e). \\
    The modulus is the product of two very large prime numbers (100 to 400 digits), represented by letters p and q (they need to be kept secret). \\
    It is a block cipher in which the plaintext and ciphertext are integers between 0 and n-1 for some n.
  \end{flushleft}
  RSA Algorithm
}

\card{\normalfont
  What are the three stepts of the \textbf{RSA algorithm}?
}{\normalfont
  \begin{flushleft}
    1. Key generation \\
    2. Encryption \\
    3. Decryption
  \end{flushleft}
  RSA Algorithm Steps
}

\card{\normalfont
  What is the pseudo-code for the \textbf{key generation} step of the \textbf{RSA algorithm}?
}{\normalfont \footnotesize
  \begin{flushleft}
    - Select two large primes (e.g. 200 digits) p and q \\
    - Calculate n = p * q and phi(n) = (p-1) * (q-1) \\
    - Select integer e relatively prime to phi(n) and 1 < e < phi(n) \\
    - Calculate d = e (to -1) mod phi(n) (or de = 1 mod phi(n)) \\
    - \textbf{Public key = {e, n}} \\
    - \textbf{Private key = {d, n}} \\
    - So: p and q are private and chosen; n= p * q is public and calculated (but keep p and q secret); e is public and chosen, and d is private and calculated.
  \end{flushleft}
  RSA Key Generation Step Pseudo Code
}

\card{\normalfont
  What is the pseudo-code for the \textbf{encryption} step of the \textbf{RSA algorithm}?
}{\normalfont
  \begin{flushleft}
    - Represent the plaintext as an integer M in [0, n-1], i.e. M < n \\
    - Ciphertext: C = M (to e) mod n
  \end{flushleft}
  RSA Encryption Step Pseudo Code
}

\card{\normalfont
  What is the pseudo-code for the \textbf{decryption} step of the \textbf{RSA algorithm}?
}{\normalfont
  \begin{flushleft}
    - Ciphertext is C \\
    - Plaintext is M = C (to d) mod n
  \end{flushleft}
  RSA Decryption Step Pseudo Code
}

\card{\normalfont
  What does the \textbf{security} of the \textbf{RSA algorithm} rely on?
}{\normalfont \small
  \begin{flushleft}
    - The security of the RSA relies on the difficulty of finding d given {e, n}. The problem of computing d from {e, n} is computationally equivalent to the problem of factoring n: if one can factorise n, then he can find p and q, and hence calculate d. \\
    - p and q should differ in length by only a few digits, and both should be on the order of 100-200 digits or even larger. n with 150 digits could be factored in about 1 year. Factoring n with 200 digits could take about 1000 years (assuming about 1012 operations per second).
  \end{flushleft}
  RSA Security
}

\flashcard{\normalfont
  The \blank{\textbf{hybrid cryptosystem}} was introduces because the \blank{\textbf{symmetric ciphers}} have key management problems and can not provide non repudiation services without the involvement of a trusted third party.
}

\flashcard{\normalfont
  \textbf{Hybrid cryptosystems} are the combination of \blank{\textbf{public key ciphers}} and \blank{\textbf{symmetric ciphers}}.
}

\card{\normalfont
  What does a \textbf{hybrid cryptosystem} contain?
}{\normalfont
  A \textbf{hybrid cryptosystem} contains a public cipher for symmetric key establishment/transportation and/or for digital signature generation and a symmetric cipher for bulk encryption.
}

\card{\normalfont
  \textbf{Hybrid cryptosystems} are used to speed thing up. This process is called \textbf{digital enveloping}. What does it entail?
}{\normalfont
  \begin{flushleft}
    - A symmetrical algorithm with a random session key (bulk encryption key) is used to encrypt the message; \\
    - A public-key algorithm is used to encrypt the random session (symmetric) key.
  \end{flushleft}
  Digital Enveloping
}

\card{\normalfont
  What are the two primary uses of \textbf{publi key cryptography}?
}{\normalfont \small
  \begin{flushleft}
    1. Key establishment \\
    \begin{flushleft}
      - Key exchange (or key transportation): a generates asymmetric key and transports it to b using b’s public key. RSA can be used for key exchange. \\
      - Key agreement: Both a and b co-operate to generate a shared key.
DH is a key agreement algorithm. \\
    \end{flushleft}
    2. Digital signatures: often using RSA or DSS (Digital Signature Standard) \\
  \end{flushleft}
  Public key cryptography provides capabilities that can not be attained with symmetric cryptography, but it is too inefficient to be used alone for large text encryption.
}


% ================================ Lecture 5 ===================================




% ================================ Lecture 6 ===================================



% ================================ Lecture 7 ===================================